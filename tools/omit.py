# omit.py
# Creates a regex for omitting files that can be used with emacs
# Not prefect but mostly works for my use cases

import re
from pathlib import Path

allowlist = ["git", "emacs"]
tests = {
    # True: Omit
    # False: Don't omit
    ".test": True,
    ".testbla": True,
    ".git": False,
    ".gitignore": False,
    ".gitmodules": False,
    ".emacs.d": False,
    ".gih": True,
    ".got": True,
    ".emeh": True,
    ".emak": True,
    ".gite": False,
    ".gem": True,
    "Desktop": False,
    "git": False,
    "emacs": False,
    ".": True,
    "..": False
}

max_len = lambda keys : max(tuple(map(len, keys)))

class TreeNode():
    def __init__(self, letter=None):
        self.letter = self._letter_check(letter)
        self.next_in_lines = []

    def _letter_check(self, letter):
        # Checks if letter is a letter and also makes it lowercase
        if letter == None:
            return None
        elif len(letter) > 1:
            raise TypeError(f"Not a letter: \"{letter}\"")
        else:
            return letter.lower()

    def search(self, letter):
        # Try to find a node with the requested letter
        for next_node in self.next_in_lines:
            if next_node.letter == self._letter_check(letter):
                return next_node
        # If we can't find a node then return None
        return None

    def append(self, letter):
        # Appends a letter to the tree
        found = self.search(letter)
        if found != None:
            return found
        # Create a new node if it doesn't exist yet
        new_node = TreeNode(letter)
        self.next_in_lines.append(new_node)
        return new_node

    def populate(self, string):
        # Appends a string of letters to the tree
        current_node = self
        for l in string:
            current_node = current_node.append(l)

    @property
    def next_letters(self):
        # Outputs next letters as a string
        letters = ""
        for n in self.next_in_lines:
            letters += n.letter
        return letters

    def __str__(self):
        # For debugging
        next_letters = []
        for n in self.next_in_lines:
            next_letters.append(n.letter)
        return f"(tree \"{self.letter}\": {next_letters})"

def generate(allow):
    # Generates a regex
    groups = TreeNode()
    re_groups = {"": "\\."}
    re_capture = []

    for a in allow:
        groups.populate(a)

    def iter(group, prev=""):
        for i in group.next_in_lines:
            try:
                re_groups[prev] += i.letter
            except KeyError:
                re_groups[prev] = i.letter
            iter(i, prev+i.letter)
            
    iter(groups)

    for key in re_groups.keys():
        re_capture.append(f"{key}[^{re_groups[key]}]")

    return f"^\\.({"|".join(re_capture)}|$)"

def test_regex(regex):
    reg = re.compile(regex)
    result = True

    for test in tests:
        success = (reg.match(test) != None)==tests[test]
        print(f"{test}{" "*(max_len(tests.keys())-len(test)+1)}", end="")
        result = result & success # If it's false, it's game over for the tests
        match success:
            case True: # Success
                print("\x1b[32m✓")
            case False: # Failed
                print("\x1b[5;31m✗")
        print("\x1b[0m", end="") # Clear ANSI codes

    return result

reg = generate(allowlist)
if test_regex(reg):
    # Generate the omit.el file
    reg = reg.replace("\\", "\\\\")
    reg = reg.replace("|", "\\\\|")
    reg = reg.replace("(", "\\\\(")
    reg = reg.replace(")", "\\\\)")
    reg = reg.replace("\'", "\\\\\'")
    reg = reg.replace("\"", "\\\\\"")
    template = f"""; Generated by ~/.emacs.d/tools/omit.py
; This file should be commited to the repository.
(provide \'omit)

(add-hook 'dired-mode-hook 'dired-omit-mode)
(setq dired-omit-files \"{reg}\")
"""
    with open(Path(__file__).parents[1] / "lisp" / "omit.el", "w") as omitel:
        print("Created omit.el")
        omitel.write(template)
else:
    raise AssertionError(f"Test failure :(\nTested regex: {reg}")

